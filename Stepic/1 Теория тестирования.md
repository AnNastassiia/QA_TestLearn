## 1.3 Кто такой тестировщик? SDLC и STLC
Жизненный цикл программного обеспечения (software lifecycle): Период времени, начинающийся с момента появления концепции программного обеспечения и заканчивающийся тогда, когда дальнейшее использование программного обеспечения невозможно. Жизненный цикл программного обеспечения обычно включает в себя следующие этапы: концепт, описание требований, дизайн, реализация, тестирование, инсталляция и наладка, эксплуатация и поддержка и, иногда, этап вывода из эксплуатации. Данные фазы могут накладываться друг на друга или проводиться итерационно. (ISTQB)

 **SDLC** - это систематизированный процесс, этапы которого охватывают полный жизненный цикл программного обеспечения (Software Lifecycle) и который определяет различные этапы разработки программного обеспечения для создания высококачественного программного обеспечения, отвечающего ожиданиям клиентов и для улучшения эффективности разработки. Разработка системы должна быть завершена в заранее определенные сроки и стоимость. Каждая фаза жизненного цикла SDLC имеет свой собственный процесс и результаты, которые используются в следующей фазе.
![](https://www.softwaretestinghelp.com/wp-content/qa/uploads/2018/04/SDLC-Cycle.jpg)
**Фазы SDLC:**

- **Сбор и анализ требований** (Requirement Gathering and Analysis): На этапе сбора и анализа требований бизнес-аналитик и менеджер проекта встречаются с заказчиком, чтобы собрать информацию о продукте, разрешить неясности и определить детали, такие как цели и функции. После анализа создается документ SRS (Спецификация требований к программному обеспечению), который должен быть понятен разработчикам и согласован с заказчиком.
- **Дизайн** (Design): На этом этапе требования, собранные в документе SRS, используются в качестве входных данных, и создается архитектура программного обеспечения, которая используется для реализации разработки системы.
- **Разработка** (Implementation or Coding): Реализация / кодирование начинается, как только разработчик получает Design document. Дизайн программного обеспечения переведен в исходный код. На этом этапе реализуются все компоненты программного обеспечения;
- **Тестирование** в SDLC начинается после кодирования, но присутствует на всех этапах, включая анализ требований. Программное обеспечение тщательно тестируется, и обнаруженные дефекты исправляются до тех пор, пока оно не будет соответствовать ожиданиям клиента. Тестировщики используют документ SRS, чтобы убедиться в соответствии продукта стандартам заказчика.
- **Развертывание** (Deployment): После тестирования продукт развертывается в производственной среде или проходит пользовательское приемочное тестирование (UAT). Если клиент доволен результатами UAT, он дает согласие на релиз.
- **Поддержка**(Maintenance): Основное внимание на этом этапе SDLC уделяется обеспечению того, чтобы потребности продолжали удовлетворяться и чтобы система продолжала работать в соответствии со спецификацией, упомянутой в первом этапе. После того, как система развернута и клиенты начинают использовать разработанную систему, следует 3 вида активностей: Исправление ошибок; Обновление; Улучшение.
**STLC** - это процесс тестирования, который включает в себя определенную последовательность шагов, чтобы гарантировать достижение целей в области качества. В процессе STLC каждое действие выполняется планомерно и систематически. Каждый этап имеет разные цели и результаты. У разных организаций разные этапы STLC, однако основа остается прежней.

**Фазы STLC**
![](https://bambooagile.eu/insights/wp-content/uploads/2021/01/In-article-STLC-copy.png)
STLC имеет несколько взаимосвязанных фаз и в целом очень похож на SDLC. Эти фазы являются последовательными и называются:
- **Анализ требований** (Requirement Analysis): один из важнейших этапов, потому что именно на нем можно почти бесплатно исправить недостатки проекта. 
- **Планирование тестирования** (Test Planning): на этом этапе формируется план тестирования, т.е. мы определяем действия и ресурсы, которые помогут достичь целей тестирования (участники и их роли, инструменты, окружение).
- **Разработка тест-кейсов** (Test Case Development): подразумевает использование ручного и автоматизированного тестирования для достижения полного охвата функциональности программного обеспечения, при этом процесс основан на заранее установленных требованиях. 
- **Настройка тестовой среды** (Test Environment Setup): в плане тестирования четко указано, какую тестовую среду следует использовать. На этом этапе STLC настраиваются операционные системы и виртуальные машины, развертываются инструменты тестирования, такие как Selenium, Katalon Studio, а также тестовая среда и базы данных проекта. 
- **Выполнение тестов** (Test Execution): тесты выполняются на основе готовой тестовой документации и правильно настроенной тестовой среды.
- **Завершение цикла испытаний** (Test Cycle Closure): окончательная генерация отчетов о тестировании для клиента. Они должны включать затраченное время, процент обнаруженных ошибок и положительных результатов тестирования, общее количество обнаруженных и исправленных ошибок. 
**Разница STLC и SDLC**
STLC и SDLC тесно связаны друг с другом, но они одновременно преследуют разные задачи с одной и той же целью, а именно:

- сбор требований в желаемой форме и разработка заявленной функциональности (SDLC);

- анализ требований, помощь клиенту и команде разработчиков и подтверждение качества реализованной функциональности (STLC).

Общая цель - удовлетворение клиента и получение максимально возможного балла на этапах верификации и валидации.

## Тестирование, контроль качества и обеспечение качества
**Тестирование** - процесс в рамках жизненного цикла разработки программного обеспечения, который оценивает качество компонента или системы, а также связанных с ними рабочих продуктов. 
**Тестирование программного обеспечения** — процесс анализа программного средства и сопутствующей документации с целью выявления дефектов и повышения качества продукта.
**Тестирование ПО** — проверка соответствия между реальным и ожидаемым поведением программы 
**Контроль качества (QC)** - набор действий, предназначенных для оценивания качества компонента или системы. 
**Обеспечение качества (QA)** - активности, направленные на обеспечение уверенности в том, что требования к качеству будут выполнены 
#### Верификация и валидация
**Верификация** - доказанное объективными результатами исследования подтверждение того, что определенные требования были выполнены. [ISTQB Glossary]
**Валидация** - подтверждение путем экспертизы того, что рабочий продукт соответствует потребностям заинтересованной стороны. [ISTQB Glossary]
**Верификация** показывает то, что продукт разработан согласно требованиям к нему и соответствует им (нуждам заказчика). Отвечает на вопрос: правильно ли мы разрабатываем продукт?
Чаще всего под верификацией подразумевают статические методы проверки (без запуска кода), которые включают в себя анализ требований, дизайна, кода.
**Валидация** показывает то, что продукт разработан согласно ожиданиям конечного пользователя (нуждам пользователя). Отвечает на вопрос: правильный ли продукт мы разработали?
Валидация включает в себя динамические проверки (с запуском кода) и тестирование уже рабочего продукта. 

## Уровни тестирования. Позитивные и негативные тесты
#### Пирамида тестирования
«Пирамида тестов» - метафора, которая означает группировку динамических тестов программного обеспечения по разным уровням. Она также дает представление, какое количество тестов должно быть в каждой из этих групп. Основной принцип разделения уровней - тест должен быть на том же уровне, что и тестируемый объект. В тесте более высокого уровня вы не тестируете всю условную логику и пограничные случаи, которые уже покрыты тестами более низкого уровня.
![](https://lh6.googleusercontent.com/yDN1s-lXbEFI5tsd429c2fT5DkHxfDNFpTotktfGZe2tdXVAdo218WSOksJIhBx5VDJffYvMOcadII_r7ln-kvX4iKFuuQ75io5IEimepSLJq_qkkZ_JH5x5UfdSXdF2PqbBPqpV)
Уровни тестирования:

* *Unit/component/program/module testing* - тестируется минимально-атомарный модуль программы, чаще всего это одна функция или метод. Таких тестов должно быть больше всего;

+ *Integration testing* - несколько модулей программы тестируются вместе;

+ *System testing* - вся программа тестируется полностью;

+ *Acceptance testing* - программа принимается заказчиком на соответствие заявленным требованиям либо тестировщики проходят end-to-end сценарии с точки зрения пользователя;
#### Модульное (юнит, компонентное) тестирование

**Компонентное тестирование  (component testing)** - уровень тестирования отдельных аппаратных или программных компонентов системы.

**Модульное тестирование (оно же юнит-тестирование)** используется для тестирования какого-либо одного логически выделенного и изолированного элемента системы (отдельные методы класса или простая функция, subprograms, subroutines, классы или процедуры) в коде.

**Компонентное тестирование** - тип тестирования ПО, при котором тестирование выполняется для каждого отдельного компонента отдельно, без интеграции с другими компонентами.
#### Интеграционное тестирование

**Интеграционное тестирование (integration testing)** - уровень тестирования, который фокусируется на взаимодействии между компонентами или системами

**Уровни интеграционного тестирования:**
* **Компонентный интеграционный уровень** (CIT - Component Integration testing): Проверяется взаимодействие между компонентами одной системы после проведения компонентного тестирования. 

* **Системный интеграционный уровень** (SIT - System Integration testing): - это полное тестирование всей системы, состоящей из множества подсистем. 

#### Системное тестирование

**Системное тестирование** означает тестирование всей системы в целом, оно выполняется после интеграционного тестирования, чтобы проверить, работает ли вся система целиком должным образом. В основном это тестирование типа «черный ящик», которое оценивает работу системы с точки зрения пользователя с помощью документа спецификации и оно не требует каких-либо внутренних знаний о системе, таких как дизайн или структура кода.

**Зачем нужно системное тестирование?**

* Очень важно завершить полный цикл тестирования, и ST - это этап, на котором это делается;

* ST выполняется в среде, аналогичной production environment, и, следовательно, заинтересованные стороны могут получить хорошее представление о реакции пользователя;

* Это помогает свести к минимуму устранение неполадок после развертывания и количество обращений в службу поддержки;

* На этом этапе STLC тестируются архитектура приложения и бизнес-требования. Это тестирование очень важно, и оно играет важную роль в предоставлении клиенту качественного продукта.

#### Приемочное тестирование

**Приемочное тестирование (acceptance testing)** - уровень тестирования, целью которого является определение того, принимать ли систему
![](https://lh5.googleusercontent.com/nNO5Lc5FT4c7yR9xl9_wzuFWCoE-ScxT5xx85O400WwPsBbv_ImGo73pDjll29ftQzRV2Csceb2e16XCvrs1NUtJYyg2IRU3EIQklLlU7Wek6t3VsOMpgXJIwGTdmOMli5qOlMvZOSfZhRY0s45a0j8qMw=s2048)

#### Позитивное, негативное и деструктивное тестирование

**Позитивное тестирование (positive testing)** - исследование приложения в ситуации, когда все действия выполняются строго по инструкции без каких бы то ни было ошибок, отклонений, ввода неверных данных и т.д.

**Негативное тестирование  (negative testing, invalid testing)** — направлено на исследование работы приложения в ситуациях, когда с ним выполняются (некорректные) операции и/или используются данные, потенциально приводящие к ошибкам (классика жанра — деление на ноль).

**Деструктивное тестирование (destructive testing)** - одна из форм негативного тестирования с целью нарушить работоспособность приложения и обнаружить точку отказа.

**В реальном тестировании следует использовать несколько правил:**
1. Любое тестирование необходимо начинать с позитивных проверок. Наша первоочередная задача убедиться, что приложение работает в стандартных условиях и готово для использования.
2. Нельзя объединять позитивные и негативные тесты, так как это затрудняет локализацию дефектов.

## Тестирование, связанное с изменениями
#### Ретест и регрессионное тестирование
**Подтверждающее (re-testing, ретест, повторное тестирование)** - тип тестирования, связанного с изменениями, которое выполняется после исправления дефекта для подтверждения того, что отказ, вызванный этим дефектом, не воспроизводится. 

**Регрессионное тестирование (regression testing)** - тип тестирования, связанного с изменениями, чтобы найти привнесенные или ранее не обнаруженные дефекты в не менявшихся областях программного обеспечения.

#### Особенности регрессионного тестирования из практики
Регрессионное тестирование является одной из самых главных активностей тестировщика и проводится перед каждым релизом (выпуском продукта для конечного пользователя).

Если релиз запланирован на каждую неделю, то регрессия проводится с такой же периодичностью, поэтому тесты для регрессии, как и дымные тесты очень часто автоматизируют для экономии времени.

Обычно для проведения регрессии выделяют несколько дней, код проекта "замораживают"(code freeze) и в него нельзя вносить изменения, кроме исправлений критичных дефектов.
#### Важно понимать: какие тесты в конечном итоге попадут в регрессионный набор? 

Регрессионные тесты выбираются из уже существующих тестовых наборов на основании следующих принципов:

* Тесты, проверяющие части приложения, в которые вносились изменения

Например, если дефект или новая функция локализованы в модуле регистрации, необходимо убедиться, что остальные компоненты этого модуля работоспособны

* Тесты с высоким приоритетом

Мы не можем рисковать работоспособностью самых важных функций приложения, поэтому необходимо дополнительно проверять и их

* Тесты, которые проверяют модули с наибольшей концентрацией дефектов

Согласно принципу скопления дефектов необходимо убедиться, что в уязвимой части приложения нет дополнительных проблем.

## Типы тестирования
#### Методы тестирования
![](https://lh6.googleusercontent.com/4hc9pyAtoQ9RCnpNmaoQkI2ZwHjtzaAipVpYQfQBTOe1QWRZFK4hZzSaR2u0SglusSzEF-nysp4Sief7_6jZN5WtnZOUNiurcf8wWFGHzzH-g_XCyi7qu-sFXybjrOXF71ZWMFzcnzfr_lTFoo8hjr8kwA=s2048)
#### Функциональное и нефункциональное тестирование

**Функциональное тестирование системы (functional testing)** включает тесты по оценке функций, которые должна выполнять система. Данный вид тестирования можно проводить на всех уровнях.

**Нефункциональное тестирование системы (non-functional testing)** выполняется для оценки таких характеристик системы и программного обеспечения, как удобство использования, производительность или безопасность. За классификацией характеристик качества программного обеспечения следует обратиться к стандарту ИСО (ISO/IEC 25010). Данный вид тестирования можно проводить на всех уровнях.

#### Классификация по степени формализации

**Тестирование на основе тест-кейсов (scripted testing, test case based testing)** — формализованный подход, в котором тестирование производится на основе заранее подготовленных тест-кейсов, наборов тест-кейсов и иной документации.

**Исследовательское тестирование (exploratory testing)** — частично формализованный подход, в рамках которого тестировщик выполняет работу с приложением по выбранному сценарию, который, в свою очередь, дорабатывается в процессе выполнения с целью более полного исследования приложения.

**Свободное (интуитивное) тестирование (ad hoc testing)** — полностью неформализованный подход, в котором не предполагается использования ни тест-кейсов, ни чек-листов, ни сценариев — тестировщик полностью опирается на свой профессионализм и интуицию (experience-based testing) для спонтанного выполнения с приложением действий, которые, как он считает, могут обнаружить ошибку. 

#### Классификация по целям и задачам

**Инсталляционное тестирование (installation testing, installability testing)** — тестирование, направленное на выявление дефектов, влияющих на протекание стадии инсталляции (установки) приложения. 

Включает в себя следующие процессы:

1. Установка ПО
2. Удаление ПО
3. Обновление ПО
4. Откат на предыдущую версию
5. Повторный запуск установки после возникновения ошибки или исправления уже возникших проблем
6. Автоматическая установка
7. Установка отдельного компонента из общего пакета программ

**Тестирование доступности (accessibility testing, A11Y)** — тестирование, направленное на исследование пригодности продукта к использованию людьми с ограниченными возможностями (слабым зрением и т.д.).
**Тестирование безопасности (security testing)** — тестирование, направленное на проверку способности приложения противостоять злонамеренным попыткам получения доступа к данным или функциям, права на доступ к которым у злоумышленника нет.

**Тестирование интернационализации (internationalization testing, i18n testing, globalization testing, localizability testing)** — тестирование, направленное на проверку готовности продукта к работе с использованием различных языков и с учётом различных национальных и культурных особенностей.

**Тестирование локализации (localization testing, l10n)** — тестирование, направленное на проверку корректности и качества адаптации продукта к использованию на том или ином языке с учётом национальных и культурных особенностей.

![](https://ucarecdn.com/6d9ae718-83e3-46a0-83ff-3b4ae0e4b804/)

**Тестирование совместимости (compatibility testing, interoperability testing)** — тестирование, направленное на проверку способности приложения работать в указанном окружении.
![](https://lh3.googleusercontent.com/31j3t9keZ0PxmNLNx0-GiM5zWnN6EFLVn8tpwJXpJqxs4bkid9pBHYYpnzmBTtubejWEyHQXDHARHq48E6rkWg0Andg7FwYFW5qk91xS_KEf-94TzsMRhjh5I2OQOBlTvav9Vynli9eLo-u8mzQWD9Nvgg=s2048)

**Тестирование надёжности (reliability testing)** — тестирование способности приложения выполнять свои функции в заданных условиях на протяжении заданного времени или заданного количества операций.

**Тестирование восстанавливаемости (recoverability testing)** — тестирование способности приложения восстанавливать свои функции и заданный уровень производительности, а также восстанавливать данные в случае возникновения критической ситуации, приводящей к временной (частичной) утрате работоспособности приложения.

**Тестирование отказоустойчивости (failover testing)** — тестирование, заключающееся в эмуляции или реальном создании критических ситуаций с целью проверки способности приложения задействовать соответствующие механизмы, предотвращающие нарушение работоспособности, производительности и повреждения данных.

**Тестирование производительности (performance testing)** — исследование показателей скорости реакции приложения на внешние воздействия при различной по характеру и интенсивности нагрузке.

**Нагрузочное тестирование** — исследование способности приложения сохранять заданные показатели качества при нагрузке в допустимых пределах и некотором превышении этих пределов (определение «запаса прочности»).

**Тестирование масштабируемости** — исследование способности приложения увеличивать показатели производительности в соответствии с увеличением количества доступных приложению ресурсов.

**Объёмное тестирование** — исследование производительности приложения при обработке различных (как правило, больших) объёмов данных.

**Стрессовое тестирование** — исследование поведения приложения при нештатных изменениях нагрузки, значительно превышающих расчётный уровень, или в ситуациях недоступности значительной части необходимых приложению ресурсов.

**Конкурентное тестирование** — исследование поведения приложения в ситуации, когда ему приходится обрабатывать большое количество одновременно поступающих запросов, что вызывает конкуренцию между запросами за ресурсы (базу данных, память, канал передачи данных, дисковую подсистему и т.д.).

## Модели разработки ПО
**Модель разработки ПО (Software Development Model, SDM)** — структура, систематизирующая различные виды проектной деятельности, их взаимодействие и последовательность в процессе разработки ПО.

**Водопадная модель (waterfall model)** сейчас представляет скорее исторический интерес, т.к. в современных проектах практически неприменима, исключая авиастроение, военную или космическую отрасли, медицину и финансовый сектор. Она предполагает однократное выполнение каждой из фаз проекта, которые, в свою очередь, строго следуют друг за другом. Очень упрощенно можно сказать, что в рамках этой модели в любой момент времени команде «видна» лишь предыдущая и следующая фаза. В реальной же разработке ПО приходится «видеть весь проект целиком» и возвращаться к предыдущим фазам, чтобы исправить недоработки или что-то уточнить.
![](https://ucarecdn.com/09edd2e4-1475-4f90-bf0a-391dcbaea7f8/)
**V-образная модель (V-model)** является логическим развитием водопадной. Можно заметить (рисунок 2.1.b), что в общем случае как водопадная, так и v-образная модели жизненного цикла ПО могут содержать один и тот же набор стадий, но принципиальное отличие заключается в том, как эта информация используется в процессе реализации проекта. Очень упрощенно можно сказать, что при использовании v-образной модели на каждой стадии «на спуске» нужно думать о том, что и как будет происходить на соответствующей стадии «на подъёме». Тестирование здесь появляется уже на самых ранних стадиях развития проекта, что позволяет минимизировать риски, а также обнаружить и устранить множество потенциальных проблем до того, как они станут проблемами реальными.
![](https://lh5.googleusercontent.com/cCYy07YlQrpb4zVCMtvVT6zcbY72OXRiowsanolLAX1m-vJlKohXehyiNukS2EPLmN1sMO30W8YRcwmVoeaeObEC9hA7HgJ1ErN9s_NVXLH_Z1E086ROaZn6El19TwYMataX5FkTJ3C01xd-0Y874cNDoQ=s2048)
**Итерационная инкрементальная модель (iterative model, incremental model)** является фундаментальной основой современного подхода к разработке ПО. Как следует из названия модели, ей свойственна определённая двойственность (а ISTQB-глоссарий даже не приводит единого определения, разбивая его на отдельные части):

- с точки зрения жизненного цикла модель является итерационной, т.к. подразумевает многократное повторение одних и тех же стадий;
- с точки зрения развития продукта (приращения его полезных функций) модель является инкрементальной.
![](https://lh3.googleusercontent.com/jiVGiJnRuxnYp-4KJ50EbNngwEs4CHFfopePwEoZrw4LyHWr6shOud8ub_MSFJbMf1dk2LgVDjxpGZRHCZlHEghQb5mQkI39KZVUj45Dzoqi3EE7QZU_OfT2LSHHA_rNu1nqYUbwhsQPKbUdulfJUVvv4A=s2048)

**Спиральная модель** представляет собой частный случай итерационной инкрементальной модели, в котором особое внимание уделяется управлению рисками, в особенности влияющими на организацию процесса разработки проекта и контрольные точки.
![](https://lh6.googleusercontent.com/gQUynjHKANlBSi9ZJC9-Y0tZlr0YWGNdpmgIEq_R6fvzNtPPR2srkCs9TrG2bLRiuSpCszENMddcvy1Ii2tSLJv_qR-Rxx9wD4fnXSFvOJUBn6sWm_NjZGSmAr-f5tuRUbpHKlQ5rjUirrgqfasWZxA5FA=s2048)

**Гибкая модель** представляет собой совокупность различных подходов к разработке ПО и базируется на т.н. «agile-манифесте».

- Люди и взаимодействие важнее процессов и инструментов.
- Работающий продукт важнее исчерпывающей документации.
- Сотрудничество с заказчиком важнее согласования условий контракта.
- Готовность к изменениям важнее следования первоначальному плану.

![](https://ucarecdn.com/8f544d81-3fe0-45aa-b1aa-feb782a63e1b/)

## Анализ требований
**Требование (requirement)** -  условие, которое включает обязательные для выполнения критерии [ISTQB Glossary]

Перед тем как к команде разработки попадают финальные требования их необходимо собрать у заказчика. Для этого используют ряд техник на рисунке ниже.

Чаще всего этим занимаются бизнес-аналитики или владельцы продукта, поэтому в курсе мы не будем акцентировать на этом пристальное внимание.
![](https://lh5.googleusercontent.com/VP1_bX8nwbEIEumxRA5D4lWtgXwbwAj5_StVZt8bMTyfd7yWgCxMSW7jtrp3E8zt9egXExZXXnfcuyb7QnfkGhKDMnHYQqGLNhsLyNuGaAigI1PgPrKjou8CJqsGMzzUDPM6kWY3zwL5mU8E0pdufC003Q=s2048)
#### Уровни и типы требований
![](https://lh3.googleusercontent.com/3pdXFy2INajZIvagsgwcZWjdO-n6jSrwxavP73fQ-XpzYV5O5daSnQguX2tDMYGQ8HCOLg-TFleR5OKDSBW5-lPr1tu-9u5WVODDbugthAx4FD0SJ2r2_t8YFUsavKmeBbaXXEQsiKPNKkiD1C3UpYvPRg=s2048)
**Бизнес-требования (business requirements)** выражают цель, ради которой разрабатывается продукт (зачем вообще он нужен, какая от него ожидается польза, как заказчик с его помощью будет получать прибыль). 

**Примеры:**

- Нужен инструмент, в реальном времени отображающий наиболее выгодный курс покупки и продажи валюты;

- Необходимо в два-три раза повысить количество заявок, обрабатываемых одним оператором за смену;

* Нужно автоматизировать процесс выписки товарно-транспортных накладных на основе договоров.

**Пользовательские требования (user requirements)** описывают задачи, которые пользователь может выполнять с помощью разрабатываемой системы (реакцию системы на действия пользователя, сценарии работы пользователя). 

Пользовательские требования оформляются в виде вариантов использования (use cases), пользовательских историй (user stories), пользовательских сценариев (user scenarios). Часть из них мы рассмотрим далее в уроке.

**Примеры:**

* При первом входе пользователя в систему должно отображаться лицензионное соглашение;

- Администратор должен иметь возможность просматривать список всех пользователей, работающих в данный момент в системе;

- При первом сохранении новой статьи система должна выдавать запрос на сохранение в виде черновика или публикацию.

**Функциональные требования (functional requirements)** описывают поведение системы, т.е. ее действия (вычисления, преобразования, проверки, обработку и т.д.). 

**Примеры:**

* В процессе инсталляции приложение должно проверять остаток свободного места на целевом носителе;

* Система должна автоматически выполнять резервное копирование данных ежедневно в указанный момент времени;

* Электронный адрес пользователя, вводимый при регистрации, должен быть проверен на соответствие требованиям RFC822.

**Нефункциональные требования (non-functional requirements)** описывают свойства системы (удобство использования, безопасность, надежность, расширяемость и т.д.), которыми она должна обладать при реализации своего поведения. 

**Примеры:**

* При одновременной непрерывной работе с системой 1000 пользователей, минимальное время между возникновением сбоев должно быть более или равно 100 часов;

* Ни при каких условиях общий объем используемой приложением памяти не может превышать 2 ГБ;

* Размер шрифта для любой надписи на экране должен поддерживать настройку в диапазоне от 5 до 15 пунктов.

**Спецификация требований (software requirements specification, SRS84)** объединяет в себе описание всех требований уровня продукта и может представлять собой весьма объёмный документ (сотни и тысячи страниц).

#### Алгоритм работы с требованиями со стороны тестировщика

**Идеальный процесс**

1. Требования создают бизнес-аналитики или владельцы продукта. Обычно они содержат в себе дизайнерские макеты.
2. Требования попадают к тестировщику, который проверяет их на соответствие свойствам качественных требований. Дополнительно в Scrum есть Backlog Refinement, где требования обсуждаются и уточняются командой на отдельном собрании.
3. В случае обнаружения неточностей, требования отправляются бизнес-аналитику на доработку, например, оставляется комментарий в системе.
4. Пункты 2-3 повторяются до тех пор, пока не будут устранены несоответствия. Параллельно требования могут изучать другие участники команды: разработчики, дизайнеры
5. После того как требования согласованы, они берутся в разработку, а тестировщики создают тестовую документацию для дальнейших проверок. Важно: тест-кейсы и чек-листы создаются до того, как функциональность из требования будет разработана. Вспоминаем Shift Left Testing и раннее тестирование. 
6. Вносить изменения в требования после начала спринта не рекомендуется и по-хорошему должно быть запрещено.

**Неидеальный процесс**

1. Анализ требований не всегда осуществляется до этапа разработки, и уточнения могут вноситься уже во время нее 
2. Тестовая документация может создаваться уже после разработки функциональности
3. Требования могут вообще не документироваться и быть на проекте в неявном виде

## Scrum
**Scrum** — легкий фреймворк, который помогает людям, командам и организациям создавать ценность с помощью адаптивных решений комплексных проблем.
**Ценности Scrum**

Успешное использование Scrum зависит от того, насколько люди разделяют пять ценностей:

**приверженность, сфокусированность, открытость, уважение и смелость.**

Scrum Team привержена своим целям и поддержке друг друга. Их важнейшим фокусом в работе в Sprint является максимально возможный прогресс в достижении целей. Scrum Team и заинтересованные лица открыты к обсуждению работы и вызовов. Участники Scrum Team уважают друг друга как профессионалов и независимых людей, и точно так же их уважают люди, с которыми они работают. Участники Scrum Team обладают смелостью поступать правильно и работать над решением сложных проблем.
#### Роли в Scrum
1. Scrum Team — небольшая команда людей, не более 10 человек.
2. Developers — это люди в Scrum Team, которые привержены созданию любого аспекта готового к использованию Increment в каждом Sprint.
3. Product Owner несет ответственность за максимизацию ценности продукта, получаемого в результате работы Scrum Team. Способы достижения максимальной ценности могут быть очень разными и зависят от организаций, Scrum Teams и конкретных людей.
4. Scrum Master несет ответственность за применение Scrum в соответствии с Руководством по Scrum. Они делают это, помогая всем понять теорию и практики Scrum, как внутри Scrum Team, так и в организации.

#### События Scrum
1. Sprint — это контейнер для всех остальных событий. Это событие фиксированной продолжительности не более одного месяца для обеспечения согласованности. Новый Sprint начинается сразу после завершения предыдущего.
2. Sprint Planning инициирует Sprint, планируя работу, которую необходимо выполнить в этом Sprint. Результатом события становится план, созданный совместными усилиями всей Scrum Team.
3. Цель Daily Scrum — инспекция прогресса в достижении Sprint Goal, адаптация Sprint Backlog по мере необходимости, корректировка запланированной предстоящей работы.
4. Цель Sprint Review — инспекция результата Sprint и выявление возможностей для адаптации. Scrum Team представляет результаты своей работы ключевым заинтересованным лицам, и обсуждает прогресс в достижении Product Goal.
5. Цель Sprint Retrospective — запланировать повышение качества и эффективности.

#### Артефакты Scrum
1. Product Backlog — это упорядоченный и постоянно обновляемый список того, что необходимо для улучшения продукта. Это единственный источник работы, выполняемой Scrum Team.
2. Sprint Backlog состоит из Sprint Goal (почему), набора выбранных на Sprint элементов Product Backlog (что), а также осуществимого плана действий по поставке Increment (как).
3. Increment — это конкретная ступенька к достижению Product Goal. Каждый Increment является дополнением ко всем предыдущим. Они тщательно проверяются для обеспечения совместной работы всех Increments. Чтобы предоставить ценность, Increment должен быть пригодным для использования.
![Шпаргалка](https://lh4.googleusercontent.com/TDaBEQKbNxlqzLGZaEseY8vUzeSGSIBL6Cd5CU1dp3wZ4W4W2RtBcyGzmrZMao4NX3mbtVchFBS09scKvHBm48JEF5pNZwlXA_RGDU-NFcJG3-yZSTosyyamUVBgK3qDqbBJk0PB5meGPXv4ENB4UmAh8w=s2048 "Шпаргалка")
